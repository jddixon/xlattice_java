/* XLMsg.java */
package org.xlattice.protocol.xl;

import java.io.IOException;
import java.security.SecureRandom;
import java.util.Vector;

import org.xlattice.protocol.TLV16;
import org.xlattice.util.StringLib;
import org.xlattice.util.UIntLib;

/**
 * This is an interim spec for an XLattice message.  This consists
 * of a fixed-length header and zero or more attributes.  The 
 * 20-byte header looks like
 *
 * <pre>
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |     XLattice message type     |        message length         |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |    
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * 
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *                          transaction ID
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *                                                                 |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * </pre>
 * 
 * In this and all other XLattice message and message attribute 
 * specifications, field values are big-endian.
 * 
 * The message length is the overall length of the message expressed
 * as an unsigned 16-bit number.  The transaction ID is a 12-byte
 * value generated by a crypto-grade random number generator.  This 
 * will sometimes be referred to as a message ID.
 * 
 * We would like to be able to precede the message with zero or 
 * more LABELs, each an 8-byte value.
 * 
 * We would also like to be able to piggyback PING and PONG messages
 * on other messages.  It might be sensible to do this by defining
 * PingAttr and PongAttr attributes, although these might interact
 * badly with message routing.
 *
 * A traceroute facility is also very desirable.
 * 
 * @author Jim Dixon
 */

public abstract class XLMsg implements XLConst {

    /** any use must be synchronized */
    protected final static SecureRandom rng = new SecureRandom();

    // INSTANCE VARIABLES ///////////////////////////////////////////
    public final int type;
    private      int length;                    // initially zero
    private      byte[] msgID;

    private final Vector attributes;
   
    protected XLMsg (int type) {
        this(type, null);
    }
    protected XLMsg (int type, byte[] msgID) {
        // XXX check type ?
        this.type = type;

        if (msgID == null) {
            msgID = new byte[MSG_ID_LENGTH];
            synchronized (rng) {
                rng.nextBytes(msgID);
            }
        } else {
            if (msgID.length != MSG_ID_LENGTH)
                throw new IllegalArgumentException(
                        "bad message ID length: " + msgID.length);
        }
        this.msgID = msgID;
        attributes = new Vector ();
    }
    // ACCESS METHODS ///////////////////////////////////////////////
    /**
     * The total length of any attributes, including the type/length
     * fields.  This number does NOT include the length of the header.
     */
    public int length () {
        return length;
    }
    public byte[] getMsgID() {
        return msgID;
    }
    /**
     * Add a TLV16 attribute to the message, updating the header's
     * length field.
     */
    public void add (XLAttr attr) {
        if (attr == null) 
            throw new IllegalArgumentException("null attribute");
        attributes.add(attr);
        // allow 4 bytes for type and attr value length
        length += 4 + attr.length();
    }
    public XLAttr get (int n) {
        return (XLAttr)attributes.get(n);
    }
    /** @return number of attributes */
    public int size() {
        return attributes.size();
    }
    /** @return byte length of serialized message */
    public int wireLength() {
        return HEADER_LENGTH + length;
    }
    // SERIALIZATION ////////////////////////////////////////////////
    public void encode(byte[] outBuf) {
        if (outBuf == null)
            throw new IllegalArgumentException("null output buffer");
        if (outBuf.length < wireLength())
            throw new IllegalStateException("output buffer of length " 
                    + outBuf.length + " cannot hold message of length "
                    + wireLength());
        if (msgID == null)
            throw new IllegalStateException("null message ID");
        
        outBuf[0] = (byte) (0xff & (type >> 8));
        outBuf[1] = (byte) type;
        outBuf[2] = (byte) (0xff & (length >> 8));
        outBuf[3] = (byte) length;
        System.arraycopy( msgID, 0, outBuf, 4, MSG_ID_LENGTH);
        
        int offset = HEADER_LENGTH;
        int count  = size();
        for (int i = 0; i < count; i++) {
            XLAttr attr = (XLAttr)attributes.get(i);
            attr.encode (outBuf, offset);
            offset += 4 + attr.length();
        }
    }
    // DESERIALIZATION //////////////////////////////////////////////
    /**
     * Read and attach attributes to previously deserialized header.
     *
     * @param msg    XLMsg being created
     * @param inBuf  buffer containing serialized message
     * @param msgLen total number of bytes in attributes
     */
    protected static void decodeAttr (XLMsg msg, byte[] inBuf, int msgLen) 
                                                throws IOException {
        int offset = HEADER_LENGTH;
        while (offset < HEADER_LENGTH + msgLen) {
            XLAttr attr = (XLAttr) XLAttr.decode (inBuf, offset);
            msg.add(attr);
            offset += 4 + attr.length();
        }
    }
    public static XLMsg decode (byte[] inBuf)   throws IOException {
        if (inBuf == null)
            throw new IllegalArgumentException("null in buffer");
        if (inBuf.length < HEADER_LENGTH)
            throw new IllegalStateException("in buffer too short: "
                    + inBuf.length);
        int _type   = UIntLib.decodeUInt16(inBuf, 0);
        int _length = UIntLib.decodeUInt16(inBuf, 2);
        byte[] _msgID = new byte[ MSG_ID_LENGTH];
        System.arraycopy (inBuf, 4, _msgID, 0, MSG_ID_LENGTH);
        XLMsg msg = null;
        
        switch (_type) {
            case PING:
                msg = new Ping(_msgID);
                break;
            case PONG:
                msg = new Pong(_msgID);
                break;
                
//          case BINDING_REQUEST:
//              BindingRequest req  = new BindingRequest(_msgID);
//              msg = req;
//              break;
//              
//          case BINDING_RESPONSE:
//              BindingResponse resp = new BindingResponse(_msgID);
//              msg = resp;
//              break;

//          case BINDING_ERROR_RESPONSE:
//              BindingErrorResponse bError 
//                                  = new BindingErrorResponse(_msgID);
//              msg = bError;
//              break;

//          case SHARED_SECRET_REQUEST:
//              SharedSecretRequest ssReq 
//                                  = new SharedSecretRequest(_msgID);
//              msg = ssReq;
//              break;

//          case SHARED_SECRET_RESPONSE:
//              SharedSecretResponse ssResp 
//                                  = new SharedSecretResponse(_msgID);
//              msg = ssResp;
//              break;

//          case SHARED_SECRET_ERROR_RESPONSE:
//              SharedSecretErrorResponse ssErr 
//                                  = new SharedSecretErrorResponse(_msgID);
//              msg = ssErr;
//              break;              // GEEP

            default:
                throw new IllegalStateException(
                        "unrecognized XLMsg type " + _type);
        }
        if (_length > 0)
            decodeAttr (msg, inBuf, _length);
        return msg;
    } 
}
